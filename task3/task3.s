    .data

input_addr:      .word  0x80
output_addr:     .word  0x84

    .text
    .org 0x88
_start:
    jal ra, init_stack            ; Jump and Link (вызов процедуры с сохранением адреса возврата в регистр ra (return address))
    jal ra, do_task
    halt

init_stack:
    addi      sp, zero, 0x500     ; Установка указателя стека на адрес 0x500
    jr        ra                  ; Возврат из процедуры

do_task:
    addi      sp, sp, -4          ; Выделяем 4 байта в стеке
    sw        ra, 0(sp)           ; Сохраняем адрес возврата из ra в стек
    lui t0, %hi(input_addr)       ; Загрузка старших 20 бит адреса ввода
    addi t0, t0, %lo(input_addr)  ; Загрузка младших 12 бит адреса ввода ; t0 = &input_addr
    lw t1, 0(t0)                  ; Загрузка значения из вдреса ввода ; t1 = M[input_addr]
    lw a0, 0(t1)                  ; Получаем сами входные данные ; a0 = M[M[input_addr]]

    jal ra, big_to_little_endian  ; Вызываем функцию, адрес возврата (pc + 4) записываем в ra и переходим смещением в (pc + k)

    lui t0, %hi(output_addr)      ; Загружаем старшие 20 бит адреса вывода 
    addi t0, t0, %lo(output_addr) ; Загружаем младшие 12 бит адреса вывода
    lw t1, 0(t0)                  ; Загружаем адрес фактического вывода
    sw a0, 0(t1)                  ; Сохраняем результат a0 в адрес вывода t1
    lw        ra, 0(sp)           ; Помещаем в ra (return address) адрес возврата из функции do_task
    addi      sp, sp, 4           ; Освобождаем место в стеке путем его смещаения
    jr        ra                  ; Возврат в точку вызова


big_to_little_endian:
    addi t5, zero, 0xFF           ; Сохраняем битовую маску, чтобы выделять байты из 32 битного слова

    mv t0, a0                     ; Копируем значение a0 в t0, чтобы работать с копией
    addi a0, zero, 0              ; Обнуляем a0, чтобы в него пошагово собрать результат
    addi t2, zero, 4              ; Максимальное число байт в слове (4 байта = 32 бита)
    addi t1, zero, 0              ; Обнуляем t1, указатель какой байт сейчас обрабатываем от 0 до 3 

; Цикл выполняется 4 раза (по байту)
byte_swap_loop:
    beq t1, t2, byte_swap_done    ; Если t1 = t2, то переходим к метке с завершением функции (то есть если все итерации прошли, переходим к выходу из функции)
    
    and t3, t0, t5                ; Достаем младший байт из t0 с помощью маски и записываем в t3
    
    ; Блок считает на сколько бит нужно сдвинуть байт, чтобы поставить его в правильное место в результирующем слове a0 ; t6 = (3 - t1) * 8
    addi t6, zero, 3              ; Загружаем в t6 значение 3
    sub t6, t6, t1                ; Вычитаем из t6 t1 (t6 = t6 - t1)
    addi t4, zero, 8              ; Загружаем в t4 значение 8
    mul t6, t6, t4                ; Умножаем t6 на t4 (t6 = t6 * t4)
    
    sll t3, t3, t6                ; Сдвиг t3 на t6 бит влево 
    or a0, a0, t3                 ; Сохраняем обратно в a0 новое место для байта
    
    addi t6, zero, 8              ; Загружаем 8 в t6 для сдвига исходного значения на 8 бит вправо (чтобы избавиться от бмладшего байта, который мы уже поместили в новое место)
    srl t0, t0, t6                ; Логический сдвиг вправо на 8 бит
    addi t1, t1, 1                ; Увеличиваем счетчик обработанных байтов на 1
    j byte_swap_loop              ; Безусловный переход к началу цикла (Jump)

byte_swap_done:
    jr ra                         ; pc = ra (то есть переходим на адрес возврата). В ra лежит следующая команда, до вызова функции big_to_little_endian